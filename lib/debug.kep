/**
 * @fileOverview Beginning and running a debug session
 */
package (
    initialize,
    
    debug,
    
    begin,
    beginProgram,
    beginInput)
with
    import 'atum/compute' compute{sequence, computeContext},
    import 'atum/compute/context' {ComputeContext},
    import 'atum/compute/statement' statement,
    import 'atum/compute/program' program,
    import 'atum/interpret' interpret,
    import 'atum/operations/evaluation' {evaluateModuleText},
    import 'atum/semantics/semantics' semantics,
    import 'atum/builtin/impl/global' global,
    import 'atum/builtin/operations/global' globalOps,
    
    import 'sheut/debug_state'  {DebugState},
    import 'sheut/state' {Debugger}
in {

var memo = \f -> {
    var val;
    return \args(...) -> {
        if (val !== undefined)
            return val;
        val = f.apply(null, args);
        return val;
    };
};

var ret = \x -> x;
var thr = \x -> { throw x; };


/**
 * Debug an existing computation.
 * 
 * Directly returns result of callbacks instead of debugger.
 * 
 * @param p Computation.
 * @param ctx Computation context.
 * @param ok Success callback.
 * @param err Error callback.
 * 
 * @return Debugger object.
 */
var execute = \p, ctx, ok, err ->
    Debugger.initial.setDebug(
        DebugState.create(
            null,
            \() -> interpret.exec(p, ctx, ok, err),
            ctx,
            false));

/* Initialization
 ******************************************************************************/
var globalContext;

initialize = memo <| \custom ->
    interpret.complete(
        sequence(
            global.initialize(),
            globalOps.enterGlobal(),
            custom || compute.empty,
            computeContext),
        ComputeContext.empty,
        \x -> { globalContext = x; return x; },
        thr);

var getGlobalContext = \-> {
    if (!globalContext)
        return initialize();
    return globalContext;
};

/* Running
 ******************************************************************************/
/**
 * Debug an existing computation.
 * 
 * @param p Computation.
 * @param ctx Computation context.
 * @param [ok] Success callback.
 * @param [err] Error callback.
 * 
 * @return Debugger object.
 */
debug = \p, ctx, ok, err -> let
    suc = (ok || ret),
    fail = (err || thr),
    pok = \x, ctx ->
        DebugState.create(null, suc(x, ctx), ctx, true),
    perr = \x, ctx ->
        DebugState.create(null, fail(x, ctx), ctx, true)
in
    execute(
        p,
        ctx,
        pok,
        perr);

/**
 * Start debugging a program in the global context.
 * 
 * @param p Computation to debug.
 * 
 * @see debug
 */
begin = \p, ok, err ->
    debug(
        p,
        getGlobalContext(),
        ok,
        err);

/**
 * Start debugging a program in the global context.
 * 
 * @param prog Program AST.
 * 
 * @see begin
 */
beginProgram = \{body}, ok, err ->
    begin(
        semantics.programBody(
            semantics.sourceElements(body)),
        ok,
        err);

/**
 * Parse a program and start debugging it in the global context
 * 
 * @param {String} text Input string.
 * 
 * @see begin
 */
beginInput = \text, ok, err ->
    begin(
        program.liftStatement(statement.liftExpression(evaluateModuleText(text))),
        ok,
        err);

}