/**
 * @fileOverview
 */
package (
// Execute
    executeContext,
    execute,
    
// Evaluate
    evaluateContext,
    evaluate,
    
// Extract
    extractContext,
    extract,

// Transform
    transformContext,
    transform
)
with
    import 'sheut/debug' {debug, 'execute': executeProgram},
    import 'sheut/state' {getResult},
    import 'sheut/step' {finish}
in {

var ret = \x -> x;
var thr = \x -> { throw x; };

/* Execute
 ******************************************************************************/
/**
 * Run `p` in provide debug context.
 * 
 * Calls continuations with the resulting debugger state and result of computation.
 * 
 * @param dctx Debug context.
 * @param p Computation.
 * @param ok Success continuation.
 * @param err Failure continuation.
 */
executeContext = \dctx, p, ok, err -> let
    result = finish(
        debug(
            p,
            dctx.ctx,
            \x, ctx -> \d -> ok(x, ctx, d),
            \x, ctx -> \d -> err(x, ctx, d)))
in
    getResult(result)(result);

/**
 * Evaluate `p` in the current context for `d`.
 * 
 * @param d Debugger state.
 *
 * @see executeContext
 */
execute = \d, p, ok, err ->
    executeContext(
        d.debug,
        p,
        ok,
        err);

/* Extract
 ******************************************************************************/
/**
 * Evaluate `p` in the given debug context,
 * 
 * @param dctx Debug context.
 * @param p Computation,
 * @param [def] Default value to return when `p` fails.
 */
evaluateContext = \dctx, p, ok, err ->
    executeContext(
        dctx,
        p,
        (ok || ret),
        (err || thr));

/**
 * Evaluate `p` in the context from `d`.
 * 
 * @param d Debugger state.
 * 
 * @see extractContext
 */
evaluate = \d, p, ok, err ->
    evaluateContext(
        d.debug,
        p,
        ok,
        err);

/* Extract
 ******************************************************************************/
/**
 * Evaluate `p` in the given debug context and return the result.
 * 
 * On failure, a default value is returned.
 * 
 * @param dctx Debug context.
 * @param p Computation,
 * @param [def] Default value to return when `p` fails.
 */
extractContext = \dctx, p, def ->
    executeContext(
        dctx,
        p,
        \x, _ -> x,
        \_, _1 -> def);

/**
 * Evaluate `p` in the context from `d`.
 * 
 * @param d Debugger state.
 * 
 * @see extractContext
 */
extract = \d, p, def ->
    extractContext(
        d.debug,
        p,
        def);

/* Transform 
 ******************************************************************************/
/**
 * Evaluate `p` in the given debug context and return the next debug context
 * resulting from evaluation.
 * 
 * @param dctx Debug context.
 * @param p Computation,
 * @param [ok] Success completion.
 * @param [err] Failure completion.
 */
transformContext = \dctx, p, ok, err ->
    finish(
        debug(
            p,
            dctx.ctx,
            ok,
            err)).debug;

/**
 * Evaluate `p` in the context from `d` and return the debugger state resulting
 * from evaluation.
 * 
 * @param d Debugger state.
 * 
 * @see transformContext
 */
transform = \d, p, ok, err ->
    d.setDebug(
        transformContext(
            d.debug,
            p,
            ok,
            err));

}