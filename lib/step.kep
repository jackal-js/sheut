/**
 * @fileOverview
 */
package (
// Operations
    step,
    finish,
    stepOver,
    stepOut,
    run)
with
    import 'atum/compute' compute,
    import 'atum/compute/tail' {trampoline},
    import 'atum/debug/debuggable' debuggable,
    import 'atum/operations/internal_reference' internal_reference,
    import 'atum/operations/value_reference' value_reference,
    import 'sheut/state' {DebugState, Debugger}
in {

var foldl = \f, z, a -> Array.prototype.reduce.call(a, f, z);

var args = \args() -> args;

var constant = \x -> \() -> x;

/* Basic Policies
 ******************************************************************************/
var always = constant(true);

var never = constant(false);

var testNext = \f ->
    \_, next ->
        f(next.debug);

var notComplete = testNext(\d -> !d.complete);

/* Policy Combinators
 ******************************************************************************/
/**
 * 
 */
var not = \p -> (p \> (!));

/**
 * 
 */
var binary = \f ->
    \a, b ->
        \current, next ->
            f(a(current, next), b(current, next));
    
/**
 * Are two policies both satisfied?
 */
var and = binary((&&));

/**
 * Are either of two policies satisfied.
 */
var or = binary((||));

/**
 * Are all of the policies satisfied.
 * 
 * @param arr Array of policies
 */
var alla = (foldl, and, always);

/**
 * Are all of the policies, passed as arguments, satisfied.
 */
var all = args \> alla;

/**
 * Are any of the policies satisfied.
 * 
 * @param arr Array of policies.
 */
var anya = (foldl, or, never);

/**
 * Are any of the policies, passed as arguments, satisfied.
 */
var any = args \> anya;

/* Breakpoint Policies
 ******************************************************************************/
var breakpoint = \current, next -> {
    for (var i = 0; i < current.breakpoints.length; ++i)
        if (current.breakpoints[i].test(next))
            return true;
    return false;
};

/* Policies
 ******************************************************************************/
var testDepth = \pred ->
    \current, next ->
        pred(next.debug.depth, current.debug.depth);

var depthGt = testDepth((>));

var depthLte = testDepth((<=));

var testDgr = \pred ->
    \_, next ->
        pred(next.debug.dgr);

var dgrInstanceof = \kind ->
    testDgr(\dgr -> dgr instanceof kind);

var debuggerDgr = dgrInstanceof(debuggable.DebuggerDebuggable);

var statementDgr = dgrInstanceof(debuggable.StatementDebuggable);

var callDgr = or(
    dgrInstanceof(debuggable.PreCallDebuggable),
    dgrInstanceof(debuggable.PostCallDebuggable));

/* Basic Operations
 ******************************************************************************/
/**
 * Perform a single step without any policy.
 * 
 * @param d Debugger.
 */
var next = let
    next = \s ->
        (s.complete ? s :
            let c = trampoline(s.k(null, s.ctx)) in
                (c instanceof debuggable.Debuggable ?
                    DebugState.create(c, c.k, c.ctx) :
                    c))
in
    \d ->
        d.setDebug(next(d.debug));

/**
 * Step while `policy` is satisfied.
 * 
 * @param policy Binary predicate taking current and next state that determines
 *    when to stop stepping.
 * @param d Debugger.
 */
var nextWhile = \policy, d -> {
    var c = d;
    do {
        c = next(c);
    } while (policy(d, c));
    return c;
};

/* Stepping Operations
 ******************************************************************************/
/**
 * Perform a single step to the next statement in the program.
 */
step = (nextWhile,
    and(
        notComplete,
        not(statementDgr)));

/**
 * Step to completion.
 */
finish = (nextWhile,
    notComplete);

/**
 * Run until a debugger statement or breakpoint is hit.
 */
run = (nextWhile,
    and(
        notComplete,
        not(debuggerDgr),
        breakpoint));

/**
 * Step over a function call.
 */
stepOver = (nextWhile,
    all(
        notComplete,
        depthGt,
        not(dgrInstanceof(debuggable.PostCallDebuggable))));

/**
 * Step out of a function call.
 */
stepOut = (nextWhile,
    and(
        notComplete,
        depthLte));

}