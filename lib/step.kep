/**
 * @fileOverview Operations for stepping through programs.
 */
package (
// Base Steps
    next,
    nextWhile,
    
// Stepping
    step,
    finish,
    run,
    stepOver,
    stepOut,
    
// Step Combinators
    sequencea,
    sequence)
with
    import 'atum/compute' compute,
    import 'atum/compute/tail' {trampoline},
    import 'atum/debug/debuggable' debuggable,
    import 'sheut/debug_state' {DebugState},
    import 'sheut/fun' {foldl, foldr, map, args, identity, constant},
    import 'sheut/policy' policy
in {

/*
 ******************************************************************************/
/*var abrupt = or(
    not(debuggerDgr),
    not(breakpoint));*/
    
/* Basic Operations
 ******************************************************************************/
/**
 * Perform a single step to the next debuggable in the program.
 * 
 * @param d Debugger.
 */
next = let
    next = \s ->
        (s.complete ? s :
            let c = trampoline(s.k(null, s.ctx)) in
                (c instanceof debuggable.Debuggable ?
                    DebugState.create(c, c.k, c.ctx) :
                    c))
in
    \d ->
        d.setDebug(next(d.debug));

/**
 * Step while `policy` is satisfied.
 * 
 * @param policy Binary predicate taking current and next state that determines
 *    when to stop stepping.
 * @param d Debugger.
 */
nextWhile = \policy, d -> {
    var c = d;
    do {
        c = next(c);
    } while (policy(d, c));
    return c;
};

/* Stepping Operations
 ******************************************************************************/
var stepNone = identity;

/**
 * Perform a single step to the next statement in the program.
 * 
 * This will hit whatever the next statement is, including inside functions.
 */
step = (nextWhile,
    policy.and(
        policy.notComplete,
        policy.not(policy.statementDgr)));

/**
 * Step to completion.
 */
finish = (nextWhile,
    policy.notComplete);

/**
 * Step until debugger statement or breakpoint is hit.
 */
run = (nextWhile,
    policy.all(
        policy.notComplete,
        policy.not(policy.debuggerDgr),
        policy.not(policy.breakpoint)));

/**
 * Step over a function call.
 * 
 * Will also stop for breakpoints and debugger statements even if these occur
 * inside of the stepped over function.
 */
stepOver = (nextWhile,
    policy.all(
        policy.notComplete,
        policy.or(
            policy.depthGt,
            policy.not(policy.statementDgr)),
        policy.not(policy.debuggerDgr)));

/**
 * Step out of a function call.
 * 
 * Will also stop for breakpoints and debugger statements even if these occur
 * inside of the stepped over function.
 * 
 * Unlike step over, this does not step to the next statement, so expression
 * with multiple function calls can step into each function.
 */
stepOut = (nextWhile,
    policy.all(
        policy.notComplete,
        policy.depthGte,
        policy.not(policy.debuggerDgr)));


/* Step Combinators
 ******************************************************************************/
/**
 * Perform one or more stepping operations in sequence left to right, returning
 * the result from the last.
 * 
 * @param steps Array of step operations.
 */
sequencea = \steps ->
    \d ->
        foldl(
            \p, c -> c(p),
            d,
            steps);

sequence = args \> sequencea;

}