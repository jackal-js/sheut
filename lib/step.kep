/**
 * @fileOverview Operations for stepping through programs.
 */
package (
// Base Steps
    next,
    nextWhile,
    
// Stepping
    step,
    finish,
    run,
    stepOver,
    stepOut,
    
// Step Combinators
    sequencea,
    sequence)
with
    import 'atum/compute' compute,
    import 'atum/compute/tail' {trampoline},
    import 'atum/debug/debuggable' debuggable,
    import 'sheut/debug_state' {DebugState},
    import 'sheut/fun' {foldl, foldr, map, args, identity, constant}
in {

/* Basic Policies
 ******************************************************************************/
var always = constant(true);

var never = constant(false);

var testNext = \f ->
    \_, next ->
        f(next.debug);

var notComplete = testNext(\d -> !d.complete);

/* Policy Combinators
 ******************************************************************************/
/**
 * 
 */
var not = \p -> (p \> (!));

/**
 * 
 */
var binary = \f ->
    \a, b ->
        \current, next ->
            f(a(current, next), b(current, next));
    
/**
 * Are two policies both satisfied?
 */
var and = binary((&&));

/**
 * Are either of two policies satisfied.
 */
var or = binary((||));

/**
 * Are all of the policies satisfied.
 * 
 * @param arr Array of policies
 */
var alla = (foldl, and, always);

/**
 * Are all of the policies, passed as arguments, satisfied.
 */
var all = args \> alla;

/**
 * Are any of the policies satisfied.
 * 
 * @param arr Array of policies.
 */
var anya = (foldl, or, never);

/**
 * Are any of the policies, passed as arguments, satisfied.
 */
var any = args \> anya;

/* Breakpoint Policies
 ******************************************************************************/
/**
 * 
 */
var breakpoint = \current{breakpoints}, next ->
    anya(
        map(
            \b -> b.test.bind(b),
            breakpoints))(current, next);

/* Depth Policies
 ******************************************************************************/
var testDepth = \pred ->
    \current, next -> 
        pred(current.debug.depth, next.debug.depth);

/**
 * Next depth is greater than current depth.
 */
var depthGt = testDepth((<));

/**
 * Next depth is greater than or equal to current depth.
 */
var depthGte = testDepth((<=));

/* Kind Policies
 ******************************************************************************/
var testDgr = \pred ->
    \_, next ->
        pred(next.debug.dgr);

var dgrInstanceof = \kind ->
    testDgr(\dgr -> dgr instanceof kind);

var debuggerDgr = dgrInstanceof(debuggable.DebuggerDebuggable);

var statementDgr = dgrInstanceof(debuggable.StatementDebuggable);

var callDgr = or(
    dgrInstanceof(debuggable.PreCallDebuggable),
    dgrInstanceof(debuggable.PostCallDebuggable));

/*
 ******************************************************************************/
var abrupt = or(
    not(debuggerDgr),
    not(breakpoint));
    
/* Basic Operations
 ******************************************************************************/
/**
 * Perform a single step to the next debuggable in the program.
 * 
 * @param d Debugger.
 */
next = let
    next = \s ->
        (s.complete ? s :
            let c = trampoline(s.k(null, s.ctx)) in
                (c instanceof debuggable.Debuggable ?
                    DebugState.create(c, c.k, c.ctx) :
                    c))
in
    \d ->
        d.setDebug(next(d.debug));

/**
 * Step while `policy` is satisfied.
 * 
 * @param policy Binary predicate taking current and next state that determines
 *    when to stop stepping.
 * @param d Debugger.
 */
nextWhile = \policy, d -> {
    var c = d;
    do {
        c = next(c);
    } while (policy(d, c));
    return c;
};

/* Stepping Operations
 ******************************************************************************/
var stepNone = identity;

/**
 * Perform a single step to the next statement in the program.
 * 
 * This will hit whatever the next statement is, including inside functions.
 */
step = (nextWhile,
    and(
        notComplete,
        not(statementDgr)));

/**
 * Step to completion.
 */
finish = (nextWhile,
    notComplete);

/**
 * Step until debugger statement or breakpoint is hit.
 */
run = (nextWhile,
    all(
        notComplete,
        not(debuggerDgr),
        not(breakpoint)));

/**
 * Step over a function call.
 * 
 * Will also stop for breakpoints and debugger statements even if these occur
 * inside of the stepped over function.
 */
stepOver = (nextWhile,
    all(
        notComplete,
        or(
            depthGt,
            not(statementDgr)),
        not(debuggerDgr)));

/**
 * Step out of a function call.
 * 
 * Will also stop for breakpoints and debugger statements even if these occur
 * inside of the stepped over function.
 * 
 * Unlike step over, this does not step to the next statement, so expression
 * with multiple function calls can step into each function.
 */
stepOut = (nextWhile,
    all(
        notComplete,
        depthGte,
        not(debuggerDgr)));


/* Step Combinators
 ******************************************************************************/
/**
 * Perform one or more stepping operations in sequence left to right, returning
 * the result from the last.
 * 
 * @param steps Array of step operations.
 */
sequencea = \steps ->
    \d ->
        foldl(
            \p, c -> c(p),
            d,
            steps);

sequence = args \> sequencea;

}